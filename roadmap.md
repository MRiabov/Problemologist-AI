# Project roadmap

## Phase 1

We rollout two agents and an environment for: creating and solving dynamics problems.

What is solved? Moving objects from one place to another, given a budget (cost) and weight. That's it.

### Prerequisites

1. A simulator, "solver" capable of solving rigid-body movements, motors
2. A LLM agent capable of solving the problems
    - Creating the agent - prompts, tools, logic
    - Tuning the agent - make it be able to actually implement this.
3. The problems themselves
    - The problems themselves are generated by another agent
        - Create and tune the agent.
    - The problems need to be validated (i.e. be solvable)

Sounds basic, but it's quite a lot of code. Think - plumbing of the agents (tool calling, having the agent write code, etc.)

#### Tech stack

1. LLMs harness - LangChain (agent basics), LangGraph (agent extras), LangFuse (agent evaluation and obserability)
2. Worker and controller code - Python, FastAPI,
3. DB - PosgreSQL, SQLite for edge devices.
4. Networking and devops - docker-compose, Docker
5. Frontend (debugging mainly) - React, Vite
6. Deployment - Railway (cheap and easy)
7. LLMs technologies - SKILL.md framework (by Anthropic)
8. Test - pytest, vitest, Playwright.

## Extensions

The above is the "MVP" of the project. It's done first. I can, and probably should do it alone, because 90% of the work is plumbing the HTTP requests, tool calling, LangChain, etc.

### Work package 1 - Tuning the agent properly

Much work will be necessary to optimize and tune the agent. Prompt adjustment against benchmarks first and foremost. Subagent development (maybe).

#### Technology stack

1. Generic Pareto optimization <https://arxiv.org/abs/2507.19457>
2. LangFuse - LLM eval framework

### Work package 2 - Fluids and deformable materials

Outside of adding just the standard rigid body simulator, add deformable bodies - that is, suitable for actual engineering, and likely fluids (fluids being both liquids and gases (gases unconfirmed)).

#### Technology stack - Fluids and deformable materials

1. Switch the solver from MuJoCo (rigid, non-deformable bodies only) to Genesis physic sim.

### Requirements - Fluids and deformable materials

#### Shared

1. Migrate to Genesis-world sim instead of MuJoCo, because it natively supports them.
2. (extra, not strictly required) Possibly, make a distributed worker architecture. The simulator and video renderers are becoming an extra worker with heavier CPU or even GPU, whereas the code, persistence, code linters, remain a small worker with very little overhead. We'll thus have controller, worker-filesystem, worker-simulator (or a similar name).

#### Deformable materials

From now on, (all) materials are subject to finite element modelling deformation.

1. All materials are now finite-element modelled, thus will bend or break, if their strength is exceeded.
2. Simulation fidelity - fair, approximately how dynamics would normally be simulated.,

We focus on more rigid body than softer materials, i.e. plastic over foam.

#### Fluids

1. Add fluids
2. If fluids are on electronics, the electronics is dead (and the agent is penalized.)
3. (extra, not strictly required) pipes and hoses? Meaning, where to transfer the fluids properly?
   - And if we add them, do we add any optimizations, such as temporarily removing the fluids from the scene to pipes?
      - And how do we do it?
   - However obviously, in production systems, all fluids are in pumps, they are not flowing freely.
4. (extra, not strictly required) Goals based on fluids? E.g. a fluid would reach a particular part of the screen, or would be connected to it.
5. Adding CAD to be able to design pipes and other vessels.

#### Agents

1. Agents are able to analyze stresses in mesh and propose optimizations based on their view of the model.
2. Agents actively prevent part breakage but don't overdesign (don't add too much material onto part).
3. Agents are notified when the part breaks.
4. If a part breaks, the simulation stops and is failed.
5. (extra, not strictly required) More or less realistic fasteners? Just to not rely on tiny fasteners supporting unrealistic weights (not doing for now.)

#### Other

1. Just in case we ever want to go back, make these togglable:
    - which simulator we use - MuJoCo or Genesis? (genesis should be a default, however putting them behind an interface is not a big problem)
    - do we use FEM? Maybe we don't want to. So make FEM togglable.
    - Simulation engine is primarily CPU since we are "researching", however GPU may also work.

#### Delivery

1. The users should be able to view the simulation results in frontend
    - (extra, not strictly required) ideally, they would be able to view it as a 3d model that they can at least pan around; including fluids and deformable materials.
       - (extra, not strictly required) ideally, with stress views
2. (extra, not strictly required) The users should be able to view how each part is deformed during the runtime of the simulation.

### Work package 3 - Electronics

Train (optimize) the model to do electrical engineering in 3d.

#### Work necessary

1. Electronics modelling in CAD
2. Optimize the agent prompts to use electronics
3. Generate more training data.

At this point we'll almost definitely need a subagent. Although, it's actually easy to do (in fact, the MVP has multiple subagents) because of LangGraph.

As said in a task description I've given to somebody:
<!-- 
```markdown
Stuff like this is already done, where LLMs is used to design circuit schematics, pick components, and design circuit boards. In the end, the goal is to make the LLM that can design both the mechanics and the electronics for it, at least on the basic level.

Goal: make a system that can: 
1. Wire up electronics for motors
2. Wire up wires in 3d space
3. Basic electronics,
4. Design such systems that electronics don't break (wires don't get torn, etc)
5. Ideally, code that can run on Arduino (saying Arduino because you likely know / heard of what Arduino is)
End result: 
The system will be able to use electronic motors, linear actuators, fluid pumps and other electromechanical with realistic wiring

Optional:
1. Lighting for end-user experience (if the user demands lighting, do lighting)
2. Buttons and other sensors. (easily implemented if we'll migrate to Genesis-world solver (a very modern simulator for robotics). That said, your implementation should be independent of the mechanics solver)

Again, this is already done (done, but fragmeneted. Nobody has "unified" all of this into electronics + mechanics). Read research papers on PCB generation, component selection, wire routing; and other stuff, you'll figure it out.
``` -->

#### Technology stack

1. SKiDL (schematics),
routing; export of PCB geometry.)
2. PySpice - a circuit simulator. Note: we don't need high-fidelity simulation. Simply calculating:
    1. motors on/off
    2. on every timestep
    is fine and is good enough.
3. MuJoCo or Genesis-world Tendonds for wires (as far as I remember).
<!-- 2. KiCad (PCBs; autorouting, perhaps. Possibly, full LLM -kicad is out of spec-->

About PySpice:
"""
Short Circuit Detection: If the Agent wires the switch directly across the battery (short circuit), SPICE will calculate massive current. You can read this value (battery.current) and fail the benchmark immediately with "Electronics Burnt."

Voltage Logic: If the Agent puts two 6V batteries in series, SPICE sees 12V. If they put them in parallel, it sees 6V. You don't have to code this logic manually; the solver does it.
"""

#### Requirements

*Note:* we have put PCBs out of the spec for now, for it adds complexity with low added value. Adding PCBs is creating a second product product into the first one.

##### Research

<!-- 1. Research exactly how these guys do it.  <https://www.flux.ai/p>. Reverse engineer their solution. It's not that difficult, but they should be very, very good at it. And there are similar companies that do it AFAIK. -->
1. Research how LLMs do schematics properly. AFAIK it should be simply

##### Shared (micro and macro)

1. (micro and macro) Ensure that electronics has enough power supply, but not too much that it would burn it.
2. Integrate circuit design to LLMs.
3. Integrate circuit simulation.
4. Integrate circuit simulation into logics.
5. (extra, not strictly required) -

##### Macro-level electronics

1. We are to able to supply electronics like motors, fluid pumps electrical power, so design a system which supports wires and ensures they aren't torn during operation. <!-- and PCBs, if they will ever appear in the project. -->
2. (extra, not strictly required) - sensors. (not done for now)

##### Micro-level electronics

1. Integrate a circuit designer for electronics (tooling for VLMs)
2. Basic chips that support running functions.
3. (extra, not strictly required) - reading from sensors and making decisions basied on sensors on chips. (not done for now)
<!-- 2. Integrate circuit design for PCBs (again, tooling for VLM) -->

##### Agents - Electronics

Agents are able to:

###### Added capability (code)

1. Use and design objects.
2. Price the circuits and validate them for manufacturability
3. Test the circuits for real-life applicability (i.e. testing them before simulation via "happy path" testing (at least))
4. Simulate the circuits in the simulator alongside other components (mechanical).
5. Detect when issues are happening in circuits.

###### Added capability (agents)

1. **Evals**. Evaluations for agents are everything, especially in this complex, planning-heavy feature.
2. Test and improve against evals.
    - Test and improve against evals combined with mechanical.

###### Extra agents

The electronics will get an extra set of agents which would communicate between themselves. Now, the central "engineer" will split into an electronics designer and into a mechanical designer.

#### Delivery - electronics

1. Users will be able to view the schematics in the UI,
2. Users will be able to view the macro wires in the UI.
3. Users will be able to view scripts on the UI (they already kind of are)
4. (extra, not strictly required) Users will be able to view how the circuit actually progresses through the simulation. E.g. what was enabled or disabled.
<!-- 2. Users will be able to view the PCB layouts in the UI, -->

##### Other - Electronics

1. The simulation would not pass if the electronics is failing - e.g. short circuit, or others.
2. Electronics is defined in `assembly_definition.yaml` (note: the `preliminary_cost_calculation.yaml` has been renamed to `assembly_definition.yaml`); under some `electronics` section.

I would note here that it appears that PCBs don't really add any value here YET, but it should be added because that's what used in production.
<!-- Or is it? they use....  -->
<!-- PCB damage -->

#### CAD

In CAD they are defined as 3d arcs (splines?), attached to certain points. The points must be next to the surface. The arcs must not intersect any volumes.

##### Out of scope

This is out of scope and will not be considered.

1. Signal (radio) transmitting, i.e. wireless.
2. Most things not related to electromechanical or control.

### Work package 4 - Adaptability

Enabling iterative refinement where engineers act as a "Co-pilot". This is the **Human-in-the-loop** steerability feature, allowing users to guide the agent through direct intervention.

#### Work necessary

1. **Hybrid Interface**: Integrate `three-cad-viewer` (topology/selection) and a Mesh viewer (R3F for simulation/stress).
2. **Steerability with Exact Pointing**:
    - Allow users to select faces, edges, or volumes in the UI and "attach" them to prompts.
    - Implement "@-mention" support for the assembly tree to target specific parts.
3. **Steering Code Directly**: Enable referencing specific code lines (e.g., `@model.py:120-125`) in chat for targeted edits.
4. **Prompt Intervention**: Optimize backend/prompts so the agent correctly interprets human corrections to its previous plans or traces.
5. **Semantic Selector Generation**: Train the agent to translate interactive `face_idx` selections into robust `build123d` code (e.g. `faces().sort_by(Axis.Z)[-1]`).

#### Technology stack

1. **three-cad-viewer**: Primary for topological selection, metadata inspection, and exact pointing.
2. **@react-three/fiber**: (Existing) Reserved for high-fidelity simulation playback, stress heatmaps, and fluid visualization.
3. **Redis/Session Store**: High-performance persistence for design state across multi-turn refinement.
4. **Line-targetted Edits**: Logic for parsing and fetching requested code ranges for the agent.

### Work package 4 - Topology optimization (extra cool)

This is definitely an extra, but adds a huge value to the project. Topology optimization:

"""
Topology optimization (TO) is a computational design method that maximizes structural performance by finding the best material layout within a given space, based on loads and constraints. By removing unnecessary material, it creates lightweight, often organic-looking, and efficient designs, heavily used in aerospace and automotive industries to minimize mass and improve strength
"""
Google it - it makes it very obvious. Essentially, it's optimization of engineering structures using AI to their peak performance (strength vs weight)
It's what every engineer wants to do, but doesn't always have time to do it. It reduces cost, makes work easier, etc, but it needs setup. Optimize the setup via the LLM.

#### Work necessary

1. Add the new tools for agents to use to make topology optimization (more CAD work).
2. Generate a new dataset with topology-optimized parts.
3. Again, tune the model to use topology optimization.
4. Possibly split the topology optimization to a more powerful CPU or even GPU machine because topology optimization is resource-intensive.

#### Technology stack

1. A topology optimization framework.
2. Prompts

### Work package 5 - Productionizing

What can we make to make the actual engineers use this?

1. Improve the models iteratively do a lot of experiments,
2. Make the simulation engineering-grade.
3. Making a better interface.
4. Add functionality that they need for enterprisey features - from most to least important (AFAIK):
    1. do they need code in their chips?
    2. More materials? More off-the-shelf parts?
    3. Thermal optimization?
    4. Reliability analysis?
    5. Extra manufacturability analysis?

    Etc.

At this point we'll the state of the art by a great margin.

#### Idea list for productionizing

- Energy conservation - set a cap on energy (which energy?) used by motors; the agent must adapt. - shouldn't be difficult to done.

### Work package 6 - Real-life scans
<!-- Later, not necessary now. -->

Take a set of real-life 3d scans, e.g. via NeRF, and instead of agent-generated environments, make the agents build small robots to move something to something in the real world.

## Extras

Below define extras. I do think they are still important, but because I'm coming up with more and more work for myself, I can't do all of this. Or I'll need to sacrifice, e.g., fluids.

### Work package 7 - Sensors
<!-- Later, not necessary now. -->

Add sensors to the simulation and make triggers based on the sensors.
Probably requires Genesis sim because sensors are natively supported there.

### Work package 8 - Design Unit Tests
<!-- Later, not necessary now. -->

Models can cover their designs with "unit tests", especially relying on sensors.
In essense, make "Unit tests" that assert functionality of a design - something was moved here at this time, a sensors detected something, something was staying above a given level, etc.

Allows for more constrained work, but also allows to strictly define and enforce "functional requirements", and allows to validate more randomization easily (e.g., not challenging to evaluate 15 random samples from the environment.)

### Work package 9 - Optimization of designs
<!-- Later, not necessary now. -->

Models will need to be optimized after the initial design. The agents will need to improve on their design substantially, beating their previous "lowest price" by at least 10-20%.

### Work package 10 - Mesh to CAD

<!-- Later, not necessary now. -->
A piece of functionality useful for Topology optimization Mesh to CAD. In essense, have the VLMs produce CAD back from topology-optimized mesh. It's simple to do (will it be as stiff/strong/lightweight though?), but will improve QOL of engineers who need to design it backwards. The mesh should be exactly reconstructed backrwards within tolerance.
