# Project roadmap

## Phase 1

We rollout two agents and an environment for: creating and solving dynamics problems.

What is solved? Moving objects from one place to another, given a budget (cost) and weight. That's it.

### Prerequisites

1. A simulator, "solver" capable of solving rigid-body movements, motors
2. A LLM agent capable of solving the problems
    - Creating the agent - prompts, tools, logic
    - Tuning the agent - make it be able to actually implement this.
3. The problems themselves
    - The problems themselves are generated by another agent
        - Create and tune the agent.
    - The problems need to be validated (i.e. be solvable)

Sounds basic, but it's quite a lot of code. Think - plumbing of the agents (tool calling, having the agent write code, etc.)

#### Tech stack

1. LLMs harness - LangChain (agent basics), LangGraph (agent extras), LangFuse (agent evaluation and obserability)
2. Worker and controller code - Python, FastAPI,
3. DB - PosgreSQL, SQLite for edge devices.
4. Networking and devops - docker-compose, Docker
5. Frontend (debugging mainly) - React, Vite
6. Deployment - Railway (cheap and easy)
7. LLMs technologies - SKILL.md framework (by Anthropic)
8. Test - pytest, vitest, Playwright.

## Extensions

The above is the "MVP" of the project. It's done first. I can, and probably should do it alone, because 90% of the work is plumbing the HTTP requests, tool calling, LangChain, etc.

### Work package 1 - Tuning the agent properly

Much work will be necessary to optimize and tune the agent. Prompt adjustment against benchmarks first and foremost. Subagent development (maybe).

#### Technology stack

1. Generic Pareto optimization <https://arxiv.org/abs/2507.19457>
2. LangFuse - LLM eval framework

### Work package 2 - Fluids and deformable materials

Outside of adding just the standard rigid body simulator, add deformable bodies - that is, suitable for actual engineering, and likely fluids (fluids being both liquids and gases (gases unconfirmed)).

#### Technology stack

1. Switch the solver from MuJoCo (rigid, non-deformable bodies only) to Genesis physic sim.

### Work package 3 - Electronics

Train the model to do electrical engineering in 3d.

#### Work necessary

1. Do a customer elecronic solver or find one that would fit
2. electronics modelling in CAD
3. Optimize the agent prompts to use electronics
4. Generate more training data.

At this point we'll almost definitely need a subagent. Although, it's actually easy to do (in fact, the MVP has multiple subagents) because of LangGraph.

As said in a task description I've given to somebody:

```markdown
Stuff like this is already done, where LLMs is used to design circuit schematics, pick components, and design circuit boards. In the end, the goal is to make the LLM that can design both the mechanics and the electronics for it, at least on the basic level.

Goal: make a system that can: 
1. Wire up electronics for motors
2. Wire up wires in 3d space
3. Basic electronics,
4. Design such systems that electronics don't break (wires don't get torn, etc)
5. Ideally, code that can run on Arduino (saying Arduino because you likely know / heard of what Arduino is)
End result: 
The system will be able to use electronic motors, linear actuators, fluid pumps and other electromechanical with realistic wiring

Optional:
1. Lighting for end-user experience (if the user demands lighting, do lighting)
2. Buttons and other sensors. (easily implemented if we'll migrate to Genesis-world solver (a very modern simulator for robotics). That said, your implementation should be independent of the mechanics solver)

Again, this is already done (done, but fragmeneted. Nobody has "unified" all of this into electronics + mechanics). Read research papers on PCB generation, component selection, wire routing; and other stuff, you'll figure it out.
```

#### Technology stack

1. A custom electronics solver! probably. I didn't find one that would suit 6-12 months ago. It's not a very complex thing - but needs to be done.

### Work package 4 - Adaptability

Just like we can prompt the Cursor or Claude code to make edits, we have to be able to allow engineers propmt too.
Up until now, all we did was a closed-loop system - we generate benchmarks from a prompt, it gets generated, then sent to an engineering LLM to be solved, it tries until succeeds/fails, and then further.

Basically, we need to hone the model to use CAD so well that it would be able to make changes to CAD on the fly (e.g. - move this part 20cm backwards and constrain it with 4 M5 bolts). Right now, it fails.

it's not necessarily a difficult piece of work, but, it'll need to plan it's changes, and execute on it.

#### Work necessary

1. New prompts
2. Adding CAD to be able to design pipes and other vessels.
3. Tuning the agent
4. A dataset of improvements. Notably, this is pretty easy to do, as we have a Critic model that would suggest improvements from day 1.
5. Extra: users can click on a certain face and say "move something on this face". The issue is that it would require, again, propmts, and a CAD viewer in frontend (4-8 hours of work?). But it's a *good* extra.

#### Tech stack

1. New prompts. LangFuse for evaluation.

### Work package 4 - Topology optimization (extra cool)

This is definitely an extra, but adds a huge value to the project. Topology optimization:

"""
Topology optimization (TO) is a computational design method that maximizes structural performance by finding the best material layout within a given space, based on loads and constraints. By removing unnecessary material, it creates lightweight, often organic-looking, and efficient designs, heavily used in aerospace and automotive industries to minimize mass and improve strength
"""
Google it - it makes it very obvious. Essentially, it's optimization of engineering structures using AI to their peak performance (strength vs weight)
It's what every engineer wants to do, but doesn't always have time to do it. It reduces cost, makes work easier, etc, but it needs setup. Optimize the setup via the LLM.

#### Work necessary

1. Add the new tools for agents to use to make topology optimization (more CAD work).
2. Generate a new dataset with topology-optimized parts.
3. Again, tune the model to use topology optimization.
4. Possibly split the topology optimization to a more powerful CPU or even GPU machine because topology optimization is resource-intensive.

#### Technology stack

1. A topology optimization framework.
2. Prompts

### Work package 5 - Productionizing

What can we make to make the actual engineers use this?

1. Improve the models iteratively do a lot of experiments,
2. Make the simulation engineering-grade.
3. Making a better interface.
4. Add functionality that they need for enterprisey features - from most to least important (AFAIK):
    1. do they need code in their chips?
    2. More materials? More off-the-shelf parts?
    3. Thermal optimization?
    4. Reliability analysis?
    5. Extra manufacturability analysis?

    Etc.

At this point we'll the state of the art by a great margin.

#### Idea list for productionizing

- Energy conservation - set a cap on energy (which energy?) used by motors; the agent must adapt. - shouldn't be difficult to done.

### Work package 6 - Real-life scans

Take a set of real-life 3d scans, e.g. via NeRF, and instead of agent-generated environments, make the agents build small robots to move something to something in the real world.

## Extras

Below define extras. I do think they are still important, but because I'm coming up with more and more work for myself, I can't do all of this. Or I'll need to sacrifice, e.g., fluids.

### Work package 7 - Sensors

Add sensors to the simulation and make triggers based on the sensors.
Probably requires Genesis sim because sensors are natively supported there.

### Work package 8 - Design Unit Tests

Models can cover their designs with "unit tests", especially relying on sensors.
In essense, make "Unit tests" that assert functionality of a design - something was moved here at this time, a sensors detected something, something was staying above a given level, etc.

Allows for more constrained work, but also allows to strictly define and enforce "functional requirements", and allows to validate more randomization easily (e.g., not challenging to evaluate 15 random samples from the environment.)

### Work package 9 - Optimization of designs

Models will need to be optimized after the initial design. The agents will need to improve on their design substantially, beating their previous "lowest price" by at least 10-20%.
