{
  "accept_commit": null,
  "acceptance_history": [
    {
      "accepted_at": "2026-02-01T18:41:10Z",
      "accepted_by": "gemini",
      "accepted_from_commit": "b7c8ee4630fedd4c7a7ac7609208b80961c67b06",
      "branch": "main",
      "mode": "local"
    },
    {
      "accepted_at": "2026-02-01T19:56:16Z",
      "accepted_by": "gemini",
      "accepted_from_commit": "3ab93943b852467abde84bf9c5ce392a34b76eb3",
      "branch": "main",
      "mode": "local"
    },
    {
      "accepted_at": "2026-02-01T19:57:54Z",
      "accepted_by": "gemini",
      "accepted_from_commit": "f0663d2534570aaf67b7330009eecabf23a74734",
      "branch": "main",
      "mode": "local"
    },
    {
      "accepted_at": "2026-02-01T19:58:27Z",
      "accepted_by": "gemini",
      "accepted_from_commit": "216c81ecc7572f401115c120ee2fb2542cf4fb3b",
      "branch": "main",
      "mode": "local"
    },
    {
      "accepted_at": "2026-02-01T19:59:51Z",
      "accepted_by": "gemini",
      "accepted_from_commit": "c3ff79fdc01226fb379c4e6a6a16019d8ad8d0e8",
      "branch": "main",
      "mode": "local"
    }
  ],
  "acceptance_mode": "local",
  "accepted_at": "2026-02-01T19:59:51Z",
  "accepted_by": "gemini",
  "accepted_from_commit": "c3ff79fdc01226fb379c4e6a6a16019d8ad8d0e8",
  "created_at": "2026-02-01T10:00:00Z",
  "feature_number": "005",
  "friendly_name": "Benchmark Scenario Generator",
  "mission": "software-dev",
  "slug": "005-benchmark-scenario-generator",
  "source_description": "benchmark scenarios. See @project-ideas.md idea 005. What's tricky is that... the last time I did this myself manually and it took a looot of time. 40 benchmarks took 4 days. This time I want to make LLMs generate it. So, create a system that would be able to generate those relatively easily. There will be a human-in-the-loop review. I'm not sure exactly how to do it, but I suppose for geometric consistency... the model that would generate it would generate a 2d matplotlib plots from top, side and bottom, and they must be actually consistent - the plots must match each other. Problems can vary in geometry that is presented, but also in goal objects. The area of the implementation is almost always defined as a box with length, height, width parameters. Problems can have small random 'forbid' zones appearing through the area to make it more challenging. Problems should be highly randomized - as much as possible. Start position, goal position, forbid zones present/missing (but within solvable range). I'v implemented this before and last time my major point of randomization was randomly reducing the goal/forbid zones by a random range of up to 40% and repositioning it within that bound. Maybe a good idea. Maybe something else can be done. [Clarifications: Python script output, XML verification final, no matplotlib, mesh exports required]",
  "target_branch": "main",
  "vcs": "git"
}
