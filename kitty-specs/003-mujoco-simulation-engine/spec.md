# Feature Specification: MuJoCo Simulation Engine & Safe Execution Environment

**Feature**: 003-mujoco-simulation-engine
**Status**: Draft
**Mission**: software-dev

## 1. Overview

The **MuJoCo Simulation Engine** has evolved into a comprehensive **Safe Execution Environment**. While it remains the physics validation backend for the Agentic CAD Environment, its role has expanded to provide a secure, containerized sandbox for executing untrusted agent code—including Python logic, data processing, and control algorithms—alongside physics simulations.

### 1.1 Secure Communication: OpenAPI

- **Host-Container Bridge**: Communication between the Host and the Container is strictly typed and governed by an **OpenAPI** schema.
- **FastAPI**: The container runs a FastAPI server that exposes endpoints for:
    - Executing CAD designs.
    - Running physics simulations.
    - Querying system status.
- **Strict Typing**: All requests and responses are validated against Pydantic models to eliminate communication errors.

## 2. Goals & Success Criteria

### 2.1. Primary Goals

1. **Secure Execution Sandbox**: Execute all untrusted agent code (Python scripts, control policies) inside isolated Podman containers.
2. **Persistent Sessions**: Support long-running container sessions where agents can execute multiple commands (`ls`, `edit`, `python run.py`) sequentially without losing state or incurring startup latency.
3. **Automated MJCF Generation**: Convert `build123d` Compound objects into valid MuJoCo XML (MJCF) assets with convex hull decomposition for accurate collisions.
4. **Zone-Based Logic**: Automatically detect special transparent volumes in the environment model (named "goal", "forbid", "start") to configure simulation logic.
5. **Complete Python Environment**: Support execution of arbitrary Python logic, not just simulation steps.
6. **Deterministic Randomization**: Support defining "Scenario Generators" where obstacles and goals are randomized per episode but reproducible via seed.

### 2.2. Success Criteria

* **Sandbox Isolation**: Zero network access for agent code (unless explicitly whitelisted). No access to host filesystem outside of mounted workspace.
* **Conversion Reliability**: 100% of valid manifolds generated by `build123d` can be successfully meshed and loaded into MuJoCo without errors.
* **Zone Detection**: Validates that "Functionally defined" zones in CAD (e.g., a red box) correctly trigger "collision events" in the physics engine.
* **Simulation Speed**: Capable of running a 10-second simulation episode in < 2 seconds wall-clock time (headless).
* **Metrics Capture**: Accurately records Energy (Joules), Task Time (s), and Violation impulses (Ns).
<!--metrics captures are TODO.-->

## 3. User Stories

### 3.1. As the Agent (Spec 002)

* **As an Agent**, I want my code to run in a real Python environment where I can import libraries and perform calculations, not just a restricted DSL.
* **As an Agent**, I want my designed mechanism to "come alive" in physics so I can prove it actually works, not just looks right.
* **As an Agent**, I want detailed feedback on *why* I failed (e.g., "Object collided with Red Zone at t=2.5s", "Script timed out") so I can fix my design or code.

### 3.2. As the Environment (Spec 001)
<!--note: poorly written. Environment isn't a "user".-->

* **As the Environment**, I want to generate a new randomized obstacle course for every episode to prevent the agent from overfitting to a single layout.
* **As the Environment**, I want to ensure the agent's control script cannot crash the host process, access the network, or leak data (Sandbox).

## 4. Functional Requirements

### 4.1. Input Processing

The engine accepts a **Simulation Bundle**:

1. **Environment Geometry**: A `build123d` Compound containing static obstacles and "Zone Volumes".
2. **Task Config**: A dictionary defining the mass/friction of the target object and the simulation duration $T$.
3. **Agent Design**: The mechanism to be tested (Compound).
4. **Agent Logic**: A Python script or set of scripts. This can be a control loop `control(sensors)` or a standalone execution script.

### 4.2. Scene Compilation (The Builder)

The system shall implement a pipeline to construct the `scene.xml`:

1. **Zone Extraction**: Identify solids named `zone_goal_*`, `zone_forbid_*`.
    * These are **removed** from visual/collision rendering.
    * They are converted into **MuJoCo Sensors/Triggers** (sites or geoms with `conaffinity=0`).
2. **Mesh Generation**:
    * Convert Agent Design & Env Obstacles to STL.
    * Perform **Convex Decomposition** (using `vhacd` or native MuJoCo primitives if possible) to generate collision meshes.
3. **Assembly**:
    * Place the Agent Design at the designated `start_zone`.
    * Place the Target Object at the `object_start`.
    * Inject Actuators (Motors) for every joint defined in the Agent's design.

### 4.3. Execution & Simulation Loop

The engine runs processes via **Podman** using an OpenAPI bridge:

1. **Container Initialization**:
    * Launch the `problemologist-sandbox` container.
    * Start the internal **FastAPI server**.
    * Wait for the OpenAPI endpoint to become healthy.
2. **Task Dispatch**:
    * Host sends an HTTP POST request to `/execute` or `/simulate` with the **Simulation Bundle**.
    * Request payload is validated against the OpenAPI schema.
3. **Internal Execution**:
    * The container's internal runner executes the CAD code or MuJoCo loop.
    * Real-time logs and intermediate metrics are buffered.
4. **Result Retrieval**:
    * The container returns a structured JSON response (Simulation Report).
    * Host parses the response and persists it to the database.

### 4.4. Output & Artifacts

Upon completion, return a **Simulation Report**:

* `outcome`: "SUCCESS", "FAIL_COLLISION", "FAIL_TIMEOUT", "FAIL_MECHANICAL", "FAIL_EXECUTION" (script error).
* `metrics`: { `energy_used`: float, `time_taken`: float, `min_distance_to_goal`: float }.
* `std_out/err`: Logs from the container execution.
* `recording`: Path to a `.mp4` or `.mjcf` replay file (optional).

## 5. Technical Design

### 5.1. Tech Stack

* **Physics**: `mujoco` (Official Python bindings).
* **Execution**: `podman` containers (rootless).
* **Mesh Proc**: `trimesh`, `pyacvd`, `vhacd`.
* **Orchestration**: Python `subprocess` wrapper around `podman run`.

### 5.2. Zone Definition Convention

We define a contract for `build123d` object naming to define simulation behavior:

| Object Name Pattern | MuJoCo Mapping | Logic |
| :--- | :--- | :--- |
| `zone_goal` | Site (Sphere/Box) | Detects if **Target Object** enters. |
| `zone_forbid` | Geom (Red, Transparent) | Detects collision with **Anything**. |
| `zone_start_agent` | Site | Spawn point for Agent mechanism. |
| `zone_start_object`| Site | Spawn point for Target Object. |
| `obstacle_*` | Geom (Static) | Standard static collision body. |

### 5.3. Agent Control Interface (Standard)

While arbitrary code is supported, the standard control interface remains:

```python
def control_policy(obs: dict, dt: float) -> dict:
    """
    Inputs:
        obs['joints']: {name: angle, ...}
        obs['object_pos']: [x, y, z]
    Returns:
        {'motor_1': 0.5, 'motor_2': -1.0}
    """
    pass
```

## 6. Assumptions & Constraints

* **Rigid Body Only**: No soft bodies or fluids in V1.
* **Friction**: Standard Coulomb friction.
* **Time Step**: Fixed at 2ms (500Hz) for stability.
* **Host Dependency**: Requires `podman` installed on the host.
* **Image**: Requires `problemologist-sandbox` image (or similar) built and available.
