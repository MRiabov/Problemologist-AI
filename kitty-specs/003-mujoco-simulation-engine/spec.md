# Feature Specification: MuJoCo Simulation Engine

**Feature**: 003-mujoco-simulation-engine
**Status**: Draft
**Mission**: software-dev

## 1. Overview

The **MuJoCo Simulation Engine** is the physics validation backend for the Agentic CAD Environment (Spec 001). It is responsible for taking a static geometric design composed by an agent (e.g., a robotic arm, a pusher mechanism) and a randomized environment definition, and simulating their interaction in a realistic physics world.

This system bridges the gap between **Static CAD** (geometry) and **Dynamic Function** (physics). It automatically converts `build123d` models into MuJoCo MJCF format, injects agent-defined control logic, and evaluates success based on spatial goals (moving objects to zones) and constraints (avoiding forbidden zones).

## 2. Goals & Success Criteria

### 2.1. Primary Goals

1. **Automated MJCF Generation**: Convert `build123d` Compound objects into valid MuJoCo XML (MJCF) assets with convex hull decomposition for accurate collisions.
2. **Zone-Based Logic**: Automatically detect special transparent volumes in the environment model (named "goal", "forbid", "start") to configure simulation logic.
3. **Agent-Defined Control**: Execute arbitrary, untrusted control scripts provided by the agent (Spec 002) to drive the mechanism during simulation.
4. **Deterministic Randomization**: Support defining "Scenario Generators" where obstacles and goals are randomized per episode but reproducible via seed.

### 2.2. Success Criteria

* **Conversion Reliability**: 100% of valid manifolds generated by `build123d` can be successfully meshed and loaded into MuJoCo without errors.
* **Zone Detection**: Validates that "Functionally defined" zones in CAD (e.g., a red box) correctly trigger "collision events" in the physics engine.
* **Simulation Speed**: Capable of running a 10-second simulation episode in < 2 seconds wall-clock time (headless).
* **Metrics Capture**: Accurately records Energy (Joules), Task Time (s), and Violation impulses (Ns).

## 3. User Stories

### 3.1. As the Agent (Spec 002)

* **As an Agent**, I want my designed mechanism to "come alive" in physics so I can prove it actually works, not just looks right.
* **As an Agent**, I want to define how my mechanism moves (e.g., "Rotate joint A at 5 rad/s") so I can solve the task.
* **As an Agent**, I want detailed feedback on *why* I failed (e.g., "Object collided with Red Zone at t=2.5s") so I can fix my design.

### 3.2. As the Environment (Spec 001)

* **As the Environment**, I want to generate a new randomized obstacle course for every episode to prevent the agent from overfitting to a single layout.
* **As the Environment**, I want to ensure the agent's control script cannot crash the host process or access the network (Sandbox).

## 4. Functional Requirements

### 4.1. Input Processing

The engine accepts a **Simulation Bundle**:

1. **Environment Geometry**: A `build123d` Compound containing static obstacles and "Zone Volumes".
2. **Task Config**: A dictionary defining the mass/friction of the target object and the simulation duration $T$.
3. **Agent Design**: The mechanism to be tested (Compound).
4. **Agent Control**: A Python script or function `control(sensors) -> actuators`.

### 4.2. Scene Compilation (The Builder)

The system shall implement a pipeline to construct the `scene.xml`:

1. **Zone Extraction**: Identify solids named `zone_goal_*`, `zone_forbid_*`.
    * These are **removed** from visual/collision rendering.
    * They are converted into **MuJoCo Sensors/Triggers** (sites or geoms with `conaffinity=0`).
2. **Mesh Generation**:
    * Convert Agent Design & Env Obstacles to STL.
    * Perform **Convex Decomposition** (using `vhacd` or native MuJoCo primitives if possible) to generate collision meshes.
3. **Assembly**:
    * Place the Agent Design at the designated `start_zone`.
    * Place the Target Object at the `object_start`.
    * Inject Actuators (Motors) for every joint defined in the Agent's design.

### 4.3. Simulation Loop

The engine runs a `mujoco` physics loop:

1. **Reset**: Load model, set seed.
2. **Step Loop** ($t=0$ to $t=T$):
    * **Sensors**: Read joint positions, object position, collision contacts.
    * **Control**: Execute `Agent.control(sensors)`.
    * **Actuate**: Apply returned torque/position signals to motors.
    * **Step**: `mj_step()`.
    * **Monitor**: Check for "Terminal Conditions":
        * **Win**: Target Object center inside Goal Zone > 1.0s.
        * **Fail**: Any part enters Forbid Zone.
        * **Fail**: Agent Design breaks (force limit exceeded).

### 4.4. Output & Artifacts

Upon completion, return a **Simulation Report**:

* `outcome`: "SUCCESS", "FAIL_COLLISION", "FAIL_TIMEOUT", "FAIL_MECHANICAL".
* `metrics`: { `energy_used`: float, `time_taken`: float, `min_distance_to_goal`: float }.
* `recording`: Path to a `.mp4` or `.mjcf` replay file (optional, for visualization).

## 5. Technical Design

### 5.1. Tech Stack

* **Physics**: `mujoco` (Official Python bindings).
* **Mesh Proc**: `trimesh` (for cleanup), `pyacvd` (optional remeshing).
* **Process**: Multiprocessing/Subprocess to isolate Agent Control logic (Safety).

### 5.2. Zone Definition Convention

We define a contract for `build123d` object naming to define simulation behavior:

| Object Name Pattern | MuJoCo Mapping | Logic |
| :--- | :--- | :--- |
| `zone_goal` | Site (Sphere/Box) | Detects if **Target Object** enters. |
| `zone_forbid` | Geom (Red, Transparent) | Detects collision with **Anything**. |
| `zone_start_agent` | Site | Spawn point for Agent mechanism. |
| `zone_start_object`| Site | Spawn point for Target Object. |
| `obstacle_*` | Geom (Static) | Standard static collision body. |

### 5.3. Agent Control Interface

The agent supplies a `controller.py` with a standard signature:

```python
def control_policy(obs: dict, dt: float) -> dict:
    """
    Inputs:
        obs['joints']: {name: angle, ...}
        obs['object_pos']: [x, y, z]
    Returns:
        {'motor_1': 0.5, 'motor_2': -1.0}
    """
    pass
```

## 6. Assumptions & Constraints

* **Rigid Body Only**: No soft bodies or fluids in V1.
* **Friction**: Standard Coulomb friction; agent shouldn't rely on complex tribology.
* **Time Step**: Fixed at 2ms (500Hz) for stability.
