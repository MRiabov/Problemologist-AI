# Feature Specification: MuJoCo Simulation Engine & Safe Execution Environment

**Feature**: 003-mujoco-simulation-engine
**Status**: Draft
**Mission**: software-dev

## 1. Overview

The **MuJoCo Simulation Engine** has evolved into a comprehensive **Safe Execution Environment**. While it remains the physics validation backend for the Agentic CAD Environment, its role has expanded to provide a secure, containerized sandbox for executing untrusted agent code—including Python logic, data processing, and control algorithms—alongside physics simulations.

This system bridges the gap between **Static CAD** (geometry) and **Dynamic Function** (physics/logic). It automatically converts `build123d` models into MuJoCo MJCF format, injects agent-defined control logic, and executes everything within isolated **Podman containers**. This ensures that agent-generated code runs safely without risking the host system, while still enabling complex interactions and robust feedback.

## 2. Goals & Success Criteria

### 2.1. Primary Goals

1. **Secure Execution Sandbox**: Execute all untrusted agent code (Python scripts, control policies) inside transient Podman containers with strict resource limits (CPU, Memory) and network isolation.
2. **Automated MJCF Generation**: Convert `build123d` Compound objects into valid MuJoCo XML (MJCF) assets with convex hull decomposition for accurate collisions.
3. **Zone-Based Logic**: Automatically detect special transparent volumes in the environment model (named "goal", "forbid", "start") to configure simulation logic.
4. **Complete Python Environment**: Support execution of arbitrary Python logic, not just simulation steps. This allows agents to perform computation, data analysis, or complex reasoning tasks within the safe environment.
5. **Deterministic Randomization**: Support defining "Scenario Generators" where obstacles and goals are randomized per episode but reproducible via seed.

### 2.2. Success Criteria

* **Sandbox Isolation**: Zero network access for agent code (unless explicitly whitelisted). No access to host filesystem outside of mounted workspace.
* **Conversion Reliability**: 100% of valid manifolds generated by `build123d` can be successfully meshed and loaded into MuJoCo without errors.
* **Zone Detection**: Validates that "Functionally defined" zones in CAD (e.g., a red box) correctly trigger "collision events" in the physics engine.
* **Simulation Speed**: Capable of running a 10-second simulation episode in < 2 seconds wall-clock time (headless).
* **Metrics Capture**: Accurately records Energy (Joules), Task Time (s), and Violation impulses (Ns).
<!--metrics captures are TODO.-->

## 3. User Stories

### 3.1. As the Agent (Spec 002)

* **As an Agent**, I want my code to run in a real Python environment where I can import libraries and perform calculations, not just a restricted DSL.
* **As an Agent**, I want my designed mechanism to "come alive" in physics so I can prove it actually works, not just looks right.
* **As an Agent**, I want detailed feedback on *why* I failed (e.g., "Object collided with Red Zone at t=2.5s", "Script timed out") so I can fix my design or code.

### 3.2. As the Environment (Spec 001)
<!--note: poorly written. Environment isn't a "user".-->

* **As the Environment**, I want to generate a new randomized obstacle course for every episode to prevent the agent from overfitting to a single layout.
* **As the Environment**, I want to ensure the agent's control script cannot crash the host process, access the network, or leak data (Sandbox).

## 4. Functional Requirements

### 4.1. Input Processing

The engine accepts a **Simulation Bundle**:

1. **Environment Geometry**: A `build123d` Compound containing static obstacles and "Zone Volumes".
2. **Task Config**: A dictionary defining the mass/friction of the target object and the simulation duration $T$.
3. **Agent Design**: The mechanism to be tested (Compound).
4. **Agent Logic**: A Python script or set of scripts. This can be a control loop `control(sensors)` or a standalone execution script.

### 4.2. Scene Compilation (The Builder)

The system shall implement a pipeline to construct the `scene.xml`:

1. **Zone Extraction**: Identify solids named `zone_goal_*`, `zone_forbid_*`.
    * These are **removed** from visual/collision rendering.
    * They are converted into **MuJoCo Sensors/Triggers** (sites or geoms with `conaffinity=0`).
2. **Mesh Generation**:
    * Convert Agent Design & Env Obstacles to STL.
    * Perform **Convex Decomposition** (using `vhacd` or native MuJoCo primitives if possible) to generate collision meshes.
3. **Assembly**:
    * Place the Agent Design at the designated `start_zone`.
    * Place the Target Object at the `object_start`.
    * Inject Actuators (Motors) for every joint defined in the Agent's design.

### 4.3. Execution & Simulation Loop

The engine runs processes via **Podman**:

1. **Container Prep**:
    * Mount workspace volume.
    * Mount `src` (optional) for library access.
    * Set strict `network="none"`, `memory="1g"`, `cpu_quota`.
2. **Execution**:
    * Launch `python script.py` inside the container.
    * For Simulations: The script initializes the MuJoCo loop.
3. **Simulation Loop** (inside container):
    * **Reset**: Load model, set seed.
    * **Step Loop** ($t=0$ to $t=T$):
        * **Sensors**: Read joint positions, object position, collision contacts.
        * **Control**: Execute `Agent.control(sensors)`.
        * **Actuate**: Apply returned torque/position signals to motors.
        * **Step**: `mj_step()`.
        * **Monitor**: Check for "Terminal Conditions".
4. **Result Extraction**:
    * Container exits.
    * Host captures `stdout`, `stderr`, and artifacts written to the workspace.

### 4.4. Output & Artifacts

Upon completion, return a **Simulation Report**:

* `outcome`: "SUCCESS", "FAIL_COLLISION", "FAIL_TIMEOUT", "FAIL_MECHANICAL", "FAIL_EXECUTION" (script error).
* `metrics`: { `energy_used`: float, `time_taken`: float, `min_distance_to_goal`: float }.
* `std_out/err`: Logs from the container execution.
* `recording`: Path to a `.mp4` or `.mjcf` replay file (optional).

## 5. Technical Design

### 5.1. Tech Stack

* **Physics**: `mujoco` (Official Python bindings).
* **Execution**: `podman` containers (rootless).
* **Mesh Proc**: `trimesh`, `pyacvd`, `vhacd`.
* **Orchestration**: Python `subprocess` wrapper around `podman run`.

### 5.2. Zone Definition Convention

We define a contract for `build123d` object naming to define simulation behavior:

| Object Name Pattern | MuJoCo Mapping | Logic |
| :--- | :--- | :--- |
| `zone_goal` | Site (Sphere/Box) | Detects if **Target Object** enters. |
| `zone_forbid` | Geom (Red, Transparent) | Detects collision with **Anything**. |
| `zone_start_agent` | Site | Spawn point for Agent mechanism. |
| `zone_start_object`| Site | Spawn point for Target Object. |
| `obstacle_*` | Geom (Static) | Standard static collision body. |

### 5.3. Agent Control Interface (Standard)

While arbitrary code is supported, the standard control interface remains:

```python
def control_policy(obs: dict, dt: float) -> dict:
    """
    Inputs:
        obs['joints']: {name: angle, ...}
        obs['object_pos']: [x, y, z]
    Returns:
        {'motor_1': 0.5, 'motor_2': -1.0}
    """
    pass
```

## 6. Assumptions & Constraints

* **Rigid Body Only**: No soft bodies or fluids in V1.
* **Friction**: Standard Coulomb friction.
* **Time Step**: Fixed at 2ms (500Hz) for stability.
* **Host Dependency**: Requires `podman` installed on the host.
* **Image**: Requires `problemologist-sandbox` image (or similar) built and available.
