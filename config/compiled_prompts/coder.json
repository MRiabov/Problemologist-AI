{
  "program.codeact": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "Coder node: Picks a task from TODO, writes code, executes it, and fixes errors.\nYou must use the provided tools to implement the current step in 'script.py'.\nWhen done, use SUBMIT to provide a summary of your work.\n\nYou are an intelligent agent. For each episode, you will receive the fields `task`, `current_step`, `plan`, `todo`, `feedback` as input.\nYour goal is to generate executable Python code that collects any necessary information for producing `journal`.\nFor each iteration, you will generate a code snippet that either solves the task or progresses towards the solution.\nEnsure any output you wish to extract from the code is printed to the console. The code should be enclosed in a fenced code block.\nWhen all information for producing the outputs (`journal`) are available to be extracted, mark `finished=True` besides the final Python code.\nYou have access to the Python Standard Library and the following functions:\n(1) search_cots_catalog, whose description is <desc>      Search for off-the-shelf mechanical and electronic components (fasteners, bearings, etc.).      Returns a list of parts with their IDs, costs, weights, and Python import recipes.        Args:          query: Text description of the part (e.g. 'M6 hex nut').          max_weight_g: Maximum allowed weight in grams.          max_cost: Maximum allowed unit cost.          category: Filter by category ('fastener', 'motor', 'gear', 'bearing', 'electronic').          limit: Max number of results.      </desc>. It takes arguments {'query': {'type': 'string'}, 'max_weight_g': {'anyOf': [{'type': 'number'}, {'type': 'null'}], 'default': None}, 'max_cost': {'anyOf': [{'type': 'number'}, {'type': 'null'}], 'default': None}, 'category': {'anyOf': [{'type': 'string'}, {'type': 'null'}], 'default': None}, 'limit': {'type': 'integer', 'default': 5}}.",
      "fields": [
        {
          "prefix": "Task:",
          "description": "${task}"
        },
        {
          "prefix": "Current Step:",
          "description": "${current_step}"
        },
        {
          "prefix": "Plan:",
          "description": "${plan}"
        },
        {
          "prefix": "Todo:",
          "description": "${todo}"
        },
        {
          "prefix": "Feedback:",
          "description": "Feedback from previous review steps"
        },
        {
          "prefix": "Trajectory:",
          "description": "${trajectory}"
        },
        {
          "prefix": "Generated Code:",
          "description": "Python code that when executed, produces output relevant to answering the question"
        },
        {
          "prefix": "Finished:",
          "description": "a boolean flag to determine if the process is done"
        }
      ]
    },
    "lm": null
  },
  "program.extractor.predict": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "Coder node: Picks a task from TODO, writes code, executes it, and fixes errors.\nYou must use the provided tools to implement the current step in 'script.py'.\nWhen done, use SUBMIT to provide a summary of your work.",
      "fields": [
        {
          "prefix": "Task:",
          "description": "${task}"
        },
        {
          "prefix": "Current Step:",
          "description": "${current_step}"
        },
        {
          "prefix": "Plan:",
          "description": "${plan}"
        },
        {
          "prefix": "Todo:",
          "description": "${todo}"
        },
        {
          "prefix": "Feedback:",
          "description": "Feedback from previous review steps"
        },
        {
          "prefix": "Trajectory:",
          "description": "${trajectory}"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Journal:",
          "description": "A summary of the implementation done for this step"
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.1.3",
      "cloudpickle": "3.1"
    }
  }
}
